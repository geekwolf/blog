<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mysql数据库 | Geekwolf's Blog]]></title>
  <link href="http://geekwolf.github.io/blog/categories/mysql数据库/atom.xml" rel="self"/>
  <link href="http://geekwolf.github.io/"/>
  <updated>2014-04-23T14:41:55+08:00</updated>
  <id>http://geekwolf.github.io/</id>
  <author>
    <name><![CDATA[Geekwolf]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[存储引擎介绍及适用场景]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/23/cun-chu-yin-qing-jie-shao-ji-gua-yong-chang-jing/"/>
    <updated>2014-04-23T14:05:56+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/23/cun-chu-yin-qing-jie-shao-ji-gua-yong-chang-jing</id>
    <content type="html"><![CDATA[<p>查看当前的默认存储引擎<br>
<code>  show variables  like 'table_type';</code></p>

<p>查看当前数据库支持的引擎<br>
<code>   show engines \G;</code><br>
<code>   show variables like 'have%';</code></p>

<!--more-->


<p>创建表时指定存储引擎<br>
<code>   create table ai (i bigint(20) not null auto_increment,primary key(i));</code><br></p>

<p>修改表引擎<br>
<code>  alter table ai engine=innodb;</code></p>

<p><strong>常见Mysql数据库引擎对比：</strong></p>

<p><img src="/images/mysql/engines.png" alt="" /></p>

<h5>一、MyISAM引擎特点：<br></h5>

<p>在磁盘存储成3个文件，文件名和表名一样，但扩展名分别为：<br>
.frm        (存储表定义)<br>
.MYD     （MYData，存储数据）<br>
.MYI       （MYIndex，存储索引）<br>
其中数据文件和索引文件可以分开在不同目录，平均分布IO</p>

<p>创建表时指定数据和索引路径：<br></p>

<p><code>create table geekwolf (id int,c varchar(10)) data directory='/data/data/' index directory='/data/index' engine='MyISAM';</code></p>

<p>MyISAM的表可能出现损坏的解决办法：<br>
check table geekwolf；检查表的健康情况<br>
repair table geekwolf；修改表<br></p>

<p>MyISAM的表引擎支持3种不同的存储格式：<br>
<strong>静态表</strong>（默认格式，固定长度，存储时按照列宽度定义补足空格；在查询时会丢失尾部的空格）<br>
<strong>动态表</strong>（频繁更新删除记录会产生碎片，占用空间相对较少，需要定期执行optimize table 或myisamchk -r来改善性能）<br>
<strong>压缩表</strong> （由myisampack工具创建）<br></p>

<p><strong>适用场景：</strong><br>
以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高的场景</p>

<h5>二、INNODB引擎特点：<br></h5>

<p><strong>1.自动增长列：</strong><br></p>

<pre><code>InnoDB表，自动增长列必须是索引，如果是组合索引，必须是组合索引的第一列；&lt;br&gt;
对于MyISAM引擎表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面激烈进行排序后递增的&lt;br&gt;
创建MyISAM表autoincre_demo&lt;br&gt;
</code></pre>

<p><code>    create table autoincre_demo (d1 smallint not null auto_increment,d2 smallint not null,name varchar(10),index(d2.d1)) engine=myisam;</code></p>

<p>如图所示：自动增长列是d1作为组合索引的第二列,插入记录后，发现增长列是按照组合索引的第一列d2进行排序后递增的</p>

<p><img src="/images/mysql/autoincre.png" alt="" /><br></p>

<p><strong>2.外键约束：</strong>
  Innodb引擎支持外键，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引<br>
  外键信息可以通过show table status like &lsquo;test&rsquo; \G;  show create table &lsquo;test&rsquo;;<br></p>

<p><strong>3.存储方式：</strong><br>
<strong>A.</strong> 使用共享表空间，这种方式创建的表结果保存在.frm文件，数据和索引保存在innodb_data_home_dir innodb_data_file_path定义的表空间中<br>
<strong>B.</strong>多表空间存储，表结构保存在.frm文件中，但是每个表的数据和索引单独存放在.ibd中；每个分区对于单独的.ibd<br>
   （需要开启innodb_file_per_table=1）<br>
 对于使用多表空间的表可以方便进行单表备份恢复，简单复制ibd和frm文件的方法因没有共享表空间的字典信息，而无法使用；多表空间情况，因为Innodb把内部的数据字典和在线重做日志存放在共享表空间里面</p>

<p><strong>使用此语句删除.ibd文件：</strong><br>
<code>ALTER TABLE tbl_name DISCARD TABLESPACE;</code><br>
要把备份的.ibd文件还原到表中，需把此文件复制到数据库目录中，然后书写此语句：<br>
<code>ALTER TABLE tbl_name IMPORT TABLESPACE;</code></p>

<p><strong>适用场景：</strong><br>
需要事务处理，对事务的完整性要求高，并发条件下要求数据一致性的计费系统或者财务系统等对数据准心要求比较搞的系统（5.5+默认引擎）</p>

<h5>三、MEMORY引擎：</h5>

<p> <strong>A.</strong>每个MEMORY表实际对应一个磁盘文件.frm，数据存放在内存，默认采用HASH索引（也可以设置撑Btree索引），服务关闭数据会丢失<br>
 <strong>B.</strong>是否memory表中的内存可以通过delete from 或者truncate 或者drop table<br>
<strong>C.</strong>memory表可以放置数据量的大小受到max_heap_table_size变量约束，默认16M，在定义表时可以用MAX_ROWS指定表的最大行数<br>
<strong>D.</strong>使用环境：用于内容变化不频繁或者作为统计操作的中间结果表</p>

<p><strong>适用场景：</strong><br>
一般用于更新不太频繁的小表，用以快速得到访问结果的环境，但对表大小有限制</p>

<h5>四、TOKUDB引擎：<br></h5>

<p>   具有高压缩率高效的插入性能，支持大多数在线DDL<br>
   与InnoDB引擎对比测试：<a href="http://www.tokutek.com/resources/tokudb-vs-innodb/">http://www.tokutek.com/resources/tokudb-vs-innodb/</a><br>
   <strong>特性：</strong><br></p>

<pre><code>使用Fractal树索引保证了高效的插入性能
优秀的压缩特性，比InnoDB高近10倍
Hot Schema Changes特性支持在线创建索引和添加/删除属性列等DDL操作
使用Bulk Loader达到快速加载大数据量
提供主从延迟消除技术
支持ACID和MVCC
</code></pre>

<p><strong>适用场景：</strong><br>
日志数据，日志通常插入频繁切存储量大；<br>
历史数据，通常不会再有写操作，可以利用TokuDB的高压缩特性存储；<br>
在线DDL较频繁的场景，使用TokuDB可以大大增加系统可用性；</p>

<p><strong>注：</strong>
具体使用哪种引擎要根据自己的业务的特点去决定</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解MySQL运算符和常用内置函数]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/09/li-jie-mysqlyun-suan-fu/"/>
    <updated>2014-04-09T14:56:41+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/09/li-jie-mysqlyun-suan-fu</id>
    <content type="html"><![CDATA[<h5>一、MySQL中的运算符</h5>

<p><img src="/images/mysql/suanshu.png" alt="" /></p>

<p><img src="/images/mysql/lj.png" alt="" /></p>

<!--more-->


<p><strong>注意事项：<br>
1.在除法运算和模数运算中，如果除数是0，将是非法除数，结果返回NULL</strong><br>
&emsp;取模运算中，也可以用MOD(a,b)函数或者a%b</p>

<pre><code>mysql&gt; select 1/0, 100%0;
+------+-------+
| 1/0 | 100%0 |
+------+-------+
| NULL | NULL |
+------+-------+
1 row in set (0.01 sec)
mysql&gt; select 3%2,mod(3,2);
+------+----------+
| 3%2 | mod(3,2) |
+------+----------+
| 1 | 1 |
+------+----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>2.NULL只能用&lt;=>进行比较，其他的比较运算符时返回NULL</strong></p>

<pre><code>mysql&gt; select 'a'&lt;'b','a'&lt;'a',1&lt;2,null&lt;=&gt;null;
+---------+---------+-----+-------------+
| 'a'&lt;'b' | 'a'&lt;'a' | 1&lt;2 | null&lt;=&gt;null |
+---------+---------+-----+-------------+
| 1 | 0 | 1 | 1 |
+---------+---------+-----+-------------+
1 row in set (0.02 sec)
mysql&gt; select 'a'&lt;'b','a'&lt;'a',1&lt;2,null&lt;null;
+---------+---------+-----+-----------+
| 'a'&lt;'b' | 'a'&lt;'a' | 1&lt;2 | null&lt;null |
+---------+---------+-----+-----------+
| 1 | 0 | 1 | NULL |
+---------+---------+-----+-----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>3.BETWEEN IN</strong><br>
&emsp;between运算符使用“a BETWEEN min AND max”当a大于等于min并且小于等于max返回1，否则返回0
&emsp;IN运算符使用"a IN（values1,values2,&hellip;)&ldquo;，当a的值存在于列表中时，则郑鄂表达式返回值1，否则0</p>

<pre><code>mysql&gt; select 10 between 10 and 20,9 between 10 and 20;
+----------------------+---------------------+
| 10 between 10 and 20 | 9 between 10 and 20 |
+----------------------+---------------------+
| 1 | 0 |
+----------------------+---------------------+
1 row in set (0.00 sec)
mysql&gt; select 1 in(1,2,3),'t' in ('t','a','b','f'),0 in(1,2);
+-------------+--------------------------+-----------+
| 1 in(1,2,3) | 't' in ('t','a','b','f') | 0 in(1,2) |
+-------------+--------------------------+-----------+
| 1 | 1 | 0 |
+-------------+--------------------------+-----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>4.REGEXP运算符格式"str REGEXP str_pat"</strong><br>
&emsp;当str字符串中含有str_pat相匹配的字符串时返回1，否则0</p>

<pre><code>mysql&gt; select 'abcdef' regexp 'ac','abcdef' regexp 'ab','abcdefg' regexp 'k';
+----------------------+----------------------+----------------------+
| 'abcdef' regexp 'ac' | 'abcdef' regexp 'ab' | 'abcdefg' regexp 'k' |
+----------------------+----------------------+----------------------+
| 0 | 1 | 0 |
+----------------------+----------------------+----------------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>5. 逻辑与AND和逻辑或OR</strong><br>
&emsp;AND：当所有操作数都为非零，并且不为NULL时，返回1；当一个或多个为0时，返回0；操作数任何一个为NULL，则返回NULL<br>
&emsp;OR   : 当两个操作数均为非NULL值时，如有任意一个为非零值，则返回1，否则0；<br>
&emsp;&emsp;&emsp; 当有一个操作数为NULL时，如另外一个为非0，则结果1，否则NULL;<br>
&emsp;&emsp;&emsp; 如果两个操作数均为NULL，则所得结果为NULL</p>

<pre><code>mysql&gt; select (1 and 1),(0 and 1),(3 and 1),(1 and null);
+-----------+-----------+-----------+--------------+
| (1 and 1) | (0 and 1) | (3 and 1) | (1 and null) |
+-----------+-----------+-----------+--------------+
| 1 | 0 | 1 | NULL |
+-----------+-----------+-----------+--------------+
1 row in set (0.00 sec)
mysql&gt; select (1 or 0),(0 or 0),(1 or null),(1 or 1),(null or null);
+----------+----------+-------------+----------+----------------+
| (1 or 0) | (0 or 0) | (1 or null) | (1 or 1) | (null or null) |
+----------+----------+-------------+----------+----------------+
| 1 | 0 | 1 | 1 | NULL |
+----------+----------+-------------+----------+----------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>6.位运算</strong><br>
&emsp;位与对多个操作数的二进制位做逻辑与操作<br></p>

<pre><code>mysql&gt; select bin(2);
+--------+
| bin(2) |
+--------+
| 10 |
+--------+
1 row in set (0.00 sec)
mysql&gt; select bin(3);
+--------+
| bin(3) |
+--------+
| 11 |
+--------+
1 row in set (0.00 sec)
mysql&gt; select bin(100);
+----------+
| bin(100) |
+----------+
| 1100100 |
+----------+
1 row in set (0.00 sec)
mysql&gt; select 2&amp;3&amp;100;
+---------+
| 2&amp;3&amp;100 |
+---------+
| 0 |
+---------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>7.位取反</strong><br>
&emsp;在MySQL中，常量数字默认会以8个字节来表示，8字节就是64位，常量1的二进制表示为63个0加1个1，位取反后就是63个1加1个0，转换成十进制后就是18446744073709551614</p>

<p><img src="/images/mysql/qf.png" alt="" /></p>

<p><strong>8.位右移</strong><br></p>

<p><img src="/images/mysql/wyy.png" alt="" /></p>

<h5>二、运算符的优先级</h5>

<p><img src="/images/mysql/yxj.png" alt="" /></p>

<h5>三、常用内置函数</h5>

<p><img src="/images/mysql/strfun.png" alt="" /></p>

<p><img src="/images/mysql/numfun.png" alt="" /></p>

<p><img src="/images/mysql/timefun.png" alt="" /></p>

<p><img src="/images/mysql/otherfun.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
date_format(date,fmt)fmt格式:<br>
<a href="http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-format">http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-format</a><br>
date_add(date,INTERVAL expr type) type类型：<br>
<a href="http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-add">http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-add</a></p>

<blockquote><p><a href="http://dev.mysql.com/doc/refman/5.5/en/functions.html">http://dev.mysql.com/doc/refman/5.5/en/functions.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql支持的数据类型]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/08/mysqlzhi-chi-de-shu-ju-lei-xing/"/>
    <updated>2014-04-08T19:36:14+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/08/mysqlzhi-chi-de-shu-ju-lei-xing</id>
    <content type="html"><![CDATA[<h5>一、数值类型</h5>

<p><img src="/images/mysql/numbers.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
<strong>1. int类型里面默认的数据宽度是11，即int(11)</strong><br>
&emsp;关于zerofill，在数字位数不够的空间用字符0填充<br>
&emsp;例如：</p>

<p><img src="/images/mysql/n2.png" alt="" /></p>

<p><strong>2.整数类型有AUTO_INCREMENT的属性</strong><br>
&emsp;AUTO_INCREMENT的值一般从1开始，每行增加1，插入NULL到一个AUTO_INCREMENT列时，Mysql插入一个比该列中当前最大值大1的值<br>
&emsp;一个表中最多只能有一个AUTO_INCREMENT列<br>
&emsp;使用AUTO_INCREMENT的条件：<br>
&emsp;该列应该定义为NOT NULL，并且为PRIMARY KEY 或者UNIQUE键<br></p>

<!--more-->


<p>&emsp;例如：</p>

<pre><code>CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,PRIMARY KEY(ID));
CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,UNIQUE(ID));
</code></pre>

<p><strong>3.BIT位数据类型查询方式</strong><br>
&emsp;bit位数据类型列不能直接查询得出结果，使用bin()显示为二进制格式，或者hex()显示为十六进制格式函数进行读取</p>

<p>&emsp;例如：</p>

<p><img src="/images/mysql/n3.png" alt="" /></p>

<h5>二、日期和时间类型</h5>

<p><img src="/images/mysql/time.png" alt="" /></p>

<p><strong>注意事项:</strong><br>
<strong>1.经常插入或者跟新日期为当前系统时间通常用TIMESTAMP来表示</strong><br>
&emsp;但是MySQL规定TIMESTAMP类型字段只能有一列的默认值为current_timestamp,第二个TIMESTAMP字段的默认值为0，即0000-00-00 00：00：00；时间与时区相关<br></p>

<p><strong>2. DATETIME是DATE和TIME的结合</strong></p>

<pre><code>mysql&gt; create table t(d date,t time,dt datetime);
Query OK, 0 rows affected (0.11 sec)
mysql&gt; desc t;
+-------+----------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d | date | YES | | NULL | |
| t | time | YES | | NULL | |
| dt | datetime | YES | | NULL | |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql&gt; select now();
+---------------------+
| now() |
+---------------------+
| 2014-04-08 11:38:24 |
+---------------------+
1 row in set (0.01 sec)
mysql&gt; insert into t values(now(),now(),now());
Query OK, 1 row affected, 1 warning (0.00 sec)
mysql&gt; show warnings;
+-------+------+----------------------------------------+
| Level | Code | Message |
+-------+------+----------------------------------------+
| Note | 1265 | Data truncated for column 'd' at row 1 |
+-------+------+----------------------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from t;
+------------+----------+---------------------+
| d | t | dt |
+------------+----------+---------------------+
| 2014-04-08 | 11:38:40 | 2014-04-08 11:38:40 |
+------------+----------+---------------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>3.TIMESTAMP 和DATETIME的区别</strong><br>
&emsp;A.TIMESTAMP支持的范围较小<br>
&emsp;B.表中第一个TIMESTAMP列自动设置为系统时间；如果列中插入NULL或者不明确的赋值都会自动设置该列的值为当前的日期和时间；超过TIMESTAMP的取值范围时，直接由0000-00-00 00：00：00填补<br>
&emsp;C.TIMESTAMP的插入和查询都受当地时区的影响，更能反应实际日期；DATETIME则只能反映出插入时当地的失去，其他时区的人查看数据必然会有误差<br></p>

<p><strong>4.YEAR</strong><br>
&emsp;有4位格式（允许的值是1901~2155、0000，默认值）的年，有2位格式（允许的值70-69，即1970~2069,Mysql5.5.27以后版本不再支持）的年</p>

<h5>三、字符串类型</h5>

<p><img src="/images/mysql/char.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
<strong>1.varchar和char的不同之处在于存储方式不同</strong><br>
&emsp;A. char列的长度固定为创建表时声明的长度，长度可以为0~255；varchar列中的值为可变长字符串，长度可以为0~65535</p>

<p><img src="/images/mysql/charst.png" alt="" /></p>

<p>&emsp;B.查询时char列删除了尾部的空格，而varchar则保留了这些空格<br>
&emsp;例如：</p>

<pre><code>mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.10 sec)
mysql&gt; INSERT INTO vc VALUES ('ab ', 'ab ');
Query OK, 1 row affected (0.00 sec)
mysql&gt; SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab ) | (ab) |
+---------------------+---------------------+
1 row in set (0.00 sec)
mysql&gt; select length(v),length(c) from vc;
+-----------+-----------+
| length(v) | length(c) |
+-----------+-----------+
| 4 | 2 |
+-----------+-----------+
1 row in set (0.00 sec)
mysql&gt; select concat(v,'+'),concat(c,'+') from vc;
+---------------+---------------+
| concat(v,'+') | concat(c,'+') |
+---------------+---------------+
| ab + | ab+ |
+---------------+---------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>2.BINARY和VARBINARY类型：</strong>类似CHAR和VARCHAR类型，不同的是它们包含二进制字符串而不包含非二进制字符串；CHAR(M)、VARCHAR(M)中的M表示字符长度，BINARY(M)和VARBINARY(M)中M表示字节的长度</p>

<p><strong>3.ENUM类型(枚举类型)</strong><br>
&emsp;对于1~255个成员的枚举需要1个字节存储，对于255~65535个成员，需要2个字节存储，最多允许65535个成员<br>
&emsp;例如:</p>

<p><img src="/images/mysql/enum.png" alt="" /></p>

<p>&emsp;ENUM类型是忽略大小写的，在存储"M" &ldquo;f"时将它们都转换成大写，插入不存在的ENUM指定的范围内的值时，并没有警告，而是插入了enum(&rsquo;M',&lsquo;F&rsquo;)的第一个值“M”，只允许从集合中选取单个值，不能一次取多个</p>

<p><strong>4.SET类型</strong><br>
&emsp;SET是一个字符串对象，包含0~64个成员，与ENUM的区别在于可以一次选取多个成员<br>
&emsp;1~8成员的集合，占1个字节<br>
&emsp;9~16成员的集合，占2个字节<br>
&emsp;17~24成员的集合，占用3个字节<br>
&emsp;25~32成员的集合，占用4个字节<br>
&emsp;33~64成员的集合，占用8个字节<br>
&emsp;例如：</p>

<pre><code>mysql&gt; create table t (col set('a','b','c','d'));
Query OK, 0 rows affected (0.22 sec)
mysql&gt; desc t;
+-------+----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------------------+------+-----+---------+-------+
| col | set('a','b','c','d') | YES | | NULL | |
+-------+----------------------+------+-----+---------+-------+
1 row in set (0.00 sec)
mysql&gt; insert into t values('a,b'),('a,d,a'),('a,b'),('a,c'),('a');
Query OK, 5 rows affected (0.00 sec)
Records: 5 Duplicates: 0 Warnings: 0
mysql&gt; select * from t;
+------+
| col |
+------+
| a,b |
| a,d |
| a,b |
| a,c |
| a |
+------+
5 rows in set (0.00 sec)
</code></pre>

<p>对于(&lsquo;a,d,a&rsquo;)这样包含重复成员的集合将取一次，写入后的结果为“a,d”</p>

<blockquote><p><a href="http://dev.mysql.com/doc/refman/5.5/en/data-types.html">http://dev.mysql.com/doc/refman/5.5/en/data-types.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sql基础操作总结]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/04/sqlji-chu-cao-zuo-zong-jie/"/>
    <updated>2014-04-04T10:29:01+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/04/sqlji-chu-cao-zuo-zong-jie</id>
    <content type="html"><![CDATA[<p>本文主要根据自己的学习过程总结的文章，可能并不全面，牛人请绕过~<br>
show create table user \G;      查看创建user表的sql<br>
<strong>修改表结构：</strong></p>

<pre><code>alter  table tablename modify[culumn] column_definition [first|after col_name]
例子：
修改emp的字段数据类型
alter table  emp modify ename varchar(20);
表首增加字段
alter table emp add column id int(10) first;
删除字段
alter table emp drop [column]  id;
字段改名 
alter table tablename change [column] old_name column_definition [first/after col_name]
更改表名
alter table emp rename [to] test;
</code></pre>

<p><strong>注释：</strong> modify只能修改字段数据类型，不能修改字段名称，first/after 表示修改字段的顺序</p>

<!--more-->


<p><strong>插入操作:</strong></p>

<pre><code>insert into table emp(f1,f2,f3) values(v1,v2,v3);
insert into table  emp values(v1,v2,v3);
一次插入多条记录
insert into table emp(f1,f2,f3)
values
(r1_v1,r2_v1,r3_v1),
(r1_v2,r2_v2,r3_v3);
</code></pre>

<p><strong>查询：</strong><br>
1.查询不重复记录 distinct</p>

<pre><code>select distinct deptno from emp;
</code></pre>

<p>2.条件查询 where<br/>
where字段比较 >、&lt;、>=、&lt;=、!= 等，多条件用or、and等
3.排序和限制 order by
排序关键字（默认是升序排列）：<br>
&emsp;&emsp;DESC 表示按照字段进行降序排列<br>
&emsp;&emsp;ASC   表所升序排列<br>
&emsp;&emsp;limit  n显示前N条记录
4.聚合操作</p>

<pre><code>语法： select [fidled1,field2,...,fieldn] fun_name
from  tablename
[where where_contition]
[group by  field1,field2,...fieldn]
[with rollup]
[having where_contition]

fun_name :表示做聚合操作的函数，比如：sum、count（*）、max、min
group by  :表示要进行分类聚合的字段
with follup ：可选，表示是否对分类聚合后的结果进行在汇总
having  ：表示在对分类后的结果在进行条件的过滤
</code></pre>

<p><strong>having和where的区别</strong><br>
&emsp;&emsp;having是对聚合后的结果进行条件的过滤，而where是在聚合前就对记录进行过滤，如果逻辑允许，我们尽可能用where先过滤记录，这样因为结果集减小，将对聚合的效率大大提高，最后在根据逻辑看是否用having进行再过滤</p>

<pre><code>例如：
 统计各个部门的人数：
 select deptno,count(1) from emp group by deptno;
 统计各个部门的人数，又要统计总人数:
 select deptno,count(1) from emp group by deptno with rollup;
 统计人数大于1的部门：
 select deptno,count(1) from emp group by deptno having count(1)&gt;1;
 统计公司所有员工的薪水总额、最高和最低薪水
 select sum(sal),max(sal),min(sal) from emp;
</code></pre>

<p>5.表连接<br>
&emsp;&emsp;表连接分为：内连接和外连接；内连接：仅选出两张表中互相匹配的记录；外连接：选出其他不匹配的记录</p>

<pre><code>例如：
 查询雇员的名字和所在部门名称（雇员和部门分属于两个表）
 select ename,deptname from emp,dept where emp.deptno=dept.deptno;
   外连接分为： 
   左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录
   右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录

例如：查询emp中所有用户和所在部门名称
select ename,deptname from dept right join emp on dept.deptno=emp.deptno;
或可用左连接代替
select ename,deptname from emp left join dept on emp.deptno=dept.deptno;
</code></pre>

<blockquote><p>表连接的好文章：
<a href="http://coolshell.cn/articles/3463.html">http://coolshell.cn/articles/3463.html</a><br>
MySQL的联结（Join）语法：
<a href="http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html">http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html</a>
6.子查询
用于子查询的关键字包括in、not in、=、!=、exits、not exits等</p></blockquote>

<pre><code>例如：
从emp表中查询出所有部门在dept表中的所有记录
select * from emp where deptno in(select deptno from dept);
可以使用表连接替换：
select emp.*  from emp,dept where emp.deptno=dept.deptno;

查询记录数唯一，可用=代替in
select * from emp where deptno = (select deptno from dept limit 1);
</code></pre>

<p>6.记录联合（union、union all）
场景：将两个表的数据按照一定的查询条件查询出来后，在合并显示
union和union all的区别在于union all把结果集直接合并在一起，而union是将union all后的结果进行了去重DISTINCT后的结果
<img src="/images/mysql/unionall.png" alt="" /><br>
<strong>查看帮助：</strong></p>

<pre><code>显示可供查询的分类
mysql&gt;? contents

针对某个分类查看帮助
mysql&gt;? data types

查看int数据类型介绍
mysql&gt;? int

查看关键字的语法
mysql&gt;? show
mysql&gt;? create table
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql事件调度器(Event Scheduler)]]></title>
    <link href="http://geekwolf.github.io/blog/2014/03/20/mysqlshi-jian-diao-du-qi-event-scheduler/"/>
    <updated>2014-03-20T18:15:54+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/03/20/mysqlshi-jian-diao-du-qi-event-scheduler</id>
    <content type="html"><![CDATA[<h5>目录:</h5>

<p><a href="#t1">一、查看当前是否开启了event scheduler三种方法:</a><br>
<a href="#t2">二、启动关闭event scheduler方法</a><br>
<a href="#t3">三、创建Event</a><br>
<a href="#t4">四、修改Event</a><br>
<a href="#t5">五、查询Event信息</a><br></p>

<p>&emsp;&emsp;Mysql中的事件调度器Event Scheduler类似于linux下的crontab计划任务的功能,它是由一个特殊的时间调度线程执行的</p>

<h5><span id="t1">一、查看当前是否开启了event scheduler三种方法</span>:</h5>

<p>1)     SHOW VARIABLES LIKE &lsquo;event_scheduler&rsquo;;<br>
2)     SELECT @@event_scheduler;<br>
3)     SHOW PROCESSLIST;(是否有State为：Waiting for next activation的进程，User为event_scheduler)<br></p>

<h5><span id="t2">二、启动关闭event scheduler方法</span>:</h5>

<p> 时间调度器是否开启由全局变量event_scheduler决定，它有三个可以设定的值：
&ndash;  OFF  : 事件调度器是关闭的，调度线程并没有运行，并且在SHOW PROCESSLIST中不显示，默认值是OFF
&ndash;  ON ：事件调度器是开启的，调度线程并没有运行，并且执行所有的调度事件，通过SHOW PROCESSLIST可以查看Waiting for next activation的进程
&ndash;  DISABLED : 设定这个值表示Event Scheduler是被禁止的，无法在Mysql运行状态下改变其值<br></p>

<!--more-->


<p>
 <strong>注：</strong>在Mysql启动时如果在my.cnf设置了event_scheduler=ON（OFF or 1 or 0）时，就不能在运行时修改撑DISABLED，如果设置event_scheduler=DISABLED时，就不能在运行时修改其值为ON （ OFF or 1 or 0）<br></p>

<pre><code>mysql&gt; SELECT @@event_scheduler;
+-------------------+
| @@event_scheduler |
+-------------------+
| DISABLED |
+-------------------+
1 row in set (0.00 sec)
mysql&gt; SET @@global.event_scheduler = 1; 
ERROR 1290 (HY000): The MySQL server is running with the --event-scheduler=DISABLED or --skip-grant-tables option so it cannot execute this statement


在mysql运行时开启Event（4种方法均可）：
SET GLOBAL event_scheduler = ON;
SET @@global.event_scheduler = ON;
SET GLOBAL event_scheduler = 1;
SET @@global.event_scheduler = 1;

在mysql运行时关闭Event（4种方法均可）：
SET GLOBAL event_scheduler = OFF;
SET @@global.event_scheduler = OFF;
SET GLOBAL event_scheduler = 0;
SET @@global.event_scheduler = 0;
</code></pre>

<h5><span id="t3">三、创建Event</span>:</h5>

<pre><code>语法：
CREATE
    [DEFINER = { user | CURRENT_USER }]
    EVENT
    [IF NOT EXISTS]
    event_name
    ON SCHEDULE schedule
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'comment']
    DO event_body;

schedule:
    AT timestamp [+ INTERVAL interval] ...
  | EVERY interval
    [STARTS timestamp [+ INTERVAL interval] ...]
    [ENDS timestamp [+ INTERVAL interval] ...]
interval:
    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
             WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
             DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
</code></pre>

<p><strong>说明：</strong></p>

<p>&emsp;&emsp;DEFINER默认是CREATE EVENT的用户,可以理解为DEFINER=CURRENT_USER,指该event的用户，服务器在执行该事件时，使用该用户来检查权限；如果设置语法:&lsquo;user_name&rsquo;@&lsquo;host_name'，如果当前CREATE EVENT用户没有supser权限，则无法将该event指派给其他用户；如果有super权限，则可以指定任意存在的用户，若不存在，时间执行时报错<br>
&emsp;&emsp;IF NOT EXISTS ： 如果在同一个schema创建一个已经存在的event_name时不会做任何操作，也不会出错，但会出现warings：该event已经存在；如果不增加此关键词已经存在的话提示ERROR： 1537 (HY000): Event 'countsum&rsquo; already exists<br>
&emsp;&emsp;ON SCHEDULE ：用于设置什么时间执行，执行的频率及执行多久的问题<br>
&emsp;&emsp;AT timestamp ：表示在给定的datetime或者timestamp的时间执行一次<br>
&emsp;&emsp;+ INTERVAL interval：表示从AT timestamp多久之后执行<br>
&emsp;&emsp;EVERY interval ：有规律的重复执行<br>
&emsp;&emsp;[ENABLE | DISABLE]可是设置该事件创建后状态是否开启或关闭，默认为ENABLE<br>
&emsp;&emsp;[COMMENT &lsquo;comment&rsquo;]可以给该事件加上注释。</p>

<pre><code>event创建时间的3周2天后：
AT  CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY

2分钟10秒： 
+ INTERVAL '2:10' MINUTE_SECOND

每6周：
EVERY 6 WEEK

从现在开始30分钟后每12小时执行一次到从现在到4周后结束执行：
EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK 
</code></pre>

<p><strong>实例：</strong><br>
前提：创建EVENT的用户需要只少对应schema的EVENT权限<br>
最基本的create event只需要三个部分：<br>
1. create event关键字以及一个event名称<br>
2. on schedule子句<br>
3. do子句<br></p>

<pre><code>1. 在创建事件myevent1小时后执行，执行一条更新

CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
DO
  UPDATE myschema.mytable SET mycol = mycol + 1;

2.2014年3月20日12点整清空test表：

CREATE EVENT e_test
    ON SCHEDULE AT TIMESTAMP '2014-03-20 12:00:00'
    DO TRUNCATE TABLE test.aaa;

3.5天后开启每天定时清空test表：

CREATE EVENT e_test
    ON SCHEDULE EVERY 1 DAY
    STARTS CURRENT_TIMESTAMP + INTERVAL 5 DAY
    DO TRUNCATE TABLE test.aaa;

4.每天定时清空test表，5天后停止执行

CREATE EVENT e_test
    ON SCHEDULE EVERY 1 DAY
    ENDS CURRENT_TIMESTAMP + INTERVAL 5 DAY
    DO TRUNCATE TABLE test.aaa;

5.5天后开启每天定时清空test表，一个月后停止执行：

CREATE EVENT e_test
    ON SCHEDULE EVERY 1 DAY
    STARTS CURRENT_TIMESTAMP + INTERVAL 5 DAY
    ENDS CURRENT_TIMESTAMP + INTERVAL 1 MONTH
    DO TRUNCATE TABLE test.aaa;

6.每天定时清空test表(只执行一次，任务完成后就终止该事件)：

CREATE EVENT e_test
    ON SCHEDULE EVERY 1 DAY
    ON COMPLETION NOT PRESERVE
    DO TRUNCATE TABLE test.aaa;

[ON COMPLETION [NOT] PRESERVE]可以设置这个事件是执行一次还是持久执行，默认为NOT PRESERVE。
</code></pre>

<h5><span id="t4">四、修改Event</span>:</h5>

<pre><code>ALTER
   [DEFINER = { user | CURRENT_USER }]
   EVENT event_name
   [ON SCHEDULE schedule]
   [ON COMPLETION [NOT] PRESERVE]
   [RENAME TO new_event_name]
   [ENABLE | DISABLE | DISABLE ON SLAVE]
   [COMMENT 'comment']
   [DO event_body]
</code></pre>

<p><strong>说明：</strong><br>
&emsp;&emsp;对于任何一个拥有定义在database里面事件的event权限的用户都可以修改event，并且成功需改后，那个用户就会成为此event的definer<br></p>

<pre><code>实例：
CREATE EVENT myevent
    ON SCHEDULE
      EVERY 6 HOUR
    COMMENT 'A sample comment.'
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;

将上面的event从开始之后每6个小时执行一次改为从开始4个小时后每12小时执行一次

只修改schedule
ALTER EVENT myevent
    ON SCHEDULE
      EVERY 12 HOUR
    STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;
同时修改schedule和body
ALTER EVENT myevent
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO
      TRUNCATE TABLE myschema.mytable;
</code></pre>

<p>关闭、启动、别名、移动、删除event：</p>

<pre><code>临时关闭某个event
ALTER EVENT myevent DISABLE;

开启某个event
ALTER EVENT myevent ENABLE;

别名某个event
ALTER EVENT olddb.myevent
RENAME TO newdb.myevent;

将myevent从olddb库移动到newdb库
ALTER EVENT olddb.myevent
RENAME TO newdb.myevent;

删除event
DROP EVENT [IF EXISTS] event_name
</code></pre>

<h5><span id="t5">五、查询Event信息</span>:</h5>

<p>Event信息相关表：<br>
information_schema.events<br>
mysql.event</p>

<p>查看事件的创建信息<br>
show create event countsum \G</p>

<p>查看sem库的events信息<br>
USE sem；<br>
SHOW EVENTS \G</p>

<p>SHOW EVENTS FROM sem;</p>

<h5>参考资料:<br></h5>

<blockquote><p><a href="https://dev.mysql.com/doc/refman/5.5/en/events.html">https://dev.mysql.com/doc/refman/5.5/en/events.html</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
