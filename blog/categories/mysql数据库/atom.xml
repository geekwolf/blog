<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mysql数据库 | Geekwolf's Blog]]></title>
  <link href="http://geekwolf.github.io/blog/categories/mysql数据库/atom.xml" rel="self"/>
  <link href="http://geekwolf.github.io/"/>
  <updated>2014-05-23T09:16:47+08:00</updated>
  <id>http://geekwolf.github.io/</id>
  <author>
    <name><![CDATA[Geekwolf]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MHA高可用部署及测试]]></title>
    <link href="http://geekwolf.github.io/blog/2014/05/17/mhagao-ke-yong-bu-shu-ji-ce-shi/"/>
    <updated>2014-05-17T10:41:14+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/05/17/mhagao-ke-yong-bu-shu-ji-ce-shi</id>
    <content type="html"><![CDATA[<p><a href="#t1">一、MHA特性</a><br>
<a href="#t2">二、MHA工作机制及failover过程解析</a><br>
<a href="#t3">三、MHA适用的主从架构</a><br>
<a href="#t4">四、MHA高可用环境的构建</a><br>
&emsp;&emsp;&emsp;&emsp;4.1 <a href="#t5">实验环境</a><br>
&emsp;&emsp;&emsp;&emsp;4.2 <a href="#t6">实验大概步骤</a><br>
&emsp;&emsp;&emsp;&emsp;4.3 <a href="#t7">相关脚本说明</a><br>
&emsp;&emsp;&emsp;&emsp;4.4 <a href="#t8">MHA部署过程</a><br>
&emsp;&emsp;&emsp;&emsp;4.5 <a href="#t9">配置VIP的方式</a><br>
<a href="#t10">五、MHA常用命令</a><br>
<a href="#t11">六、注意事项</a><br>
<a href="#t12">七、部署过程遇到的问题</a><br></p>

<h5><span id="t1">一.MHA特性</span></h5>

<p>1.主服务器的自动监控和故障转移 <br>
&emsp;&emsp;MHA监控复制架构的主服务器，一旦检测到主服务器故障，就会自动进行故障转移。即使有些从服务器没有收到最新的relay log，MHA自动从最新的从服务器上识别差异的relay log并把这些日志应用到其他从服务器上，因此所有的从服务器保持一致性了。MHA通常在几秒内完成故障转移，9-12秒可以检测出主服务器故障，7-10秒内关闭故障的主服务器以避免脑裂，几秒中内应用差异的relay log到新的主服务器上，整个过程可以在10-30s内完成。还可以设置优先级指定其中的一台slave作为master的候选人。由于MHA在slaves之间修复一致性，因此可以将任何slave变成新的master，而不会发生一致性的问题，从而导致复制失败。<br>
2.交互式主服务器故障转移 <br></p>

<!--more-->


<p>&emsp;&emsp;可以只使用MHA的故障转移，而不用于监控主服务器，当主服务器故障时，人工调用MHA来进行故障故障。<br>
3.非交互式的主故障转移 <br>
&emsp;&emsp;不监控主服务器，但自动实现故障转移。这种特征适用于已经使用其他软件来监控主服务器状态，比如heartbeat来检测主服务器故障和虚拟IP地址接管，可以使用MHA来实现故障转移和slave服务器晋级为master服务器。<br>
4.在线切换主服务器 <br>
&emsp;&emsp;在许多情况下，需要将现有的主服务器迁移到另外一台服务器上。比如主服务器硬件故障，RAID控制卡需要重建，将主服务器移到性能更好的服务器上等等。维护主服务器引起性能下降，导致停机时间至少无法写入数据。另外，阻塞或杀掉当前运行的会话会导致主主之间数据不一致的问题发生。MHA提供快速切换和优雅的阻塞写入，这个切换过程只需要0.5-2s的时间，这段时间内数据是无法写入的。在很多情况下，0.5-2s的阻塞写入是可以接受的。因此切换主服务器不需要计划分配维护时间窗口(呵呵，不需要你在夜黑风高时通宵达旦完成切换主服务器的任务)。<br></p>

<!--more-->


<h5><span id="t2">二.MHA工作机制</span></h5>

<p>MHA自动Failover过程解析<br>
<a href="http://www.mysqlsystems.com/2012/03/figure-out-process-of-autofailover-on-mha.html">http://www.mysqlsystems.com/2012/03/figure-out-process-of-autofailover-on-mha.html</a><br>
<a href="https://code.google.com/p/mysql-master-ha/wiki/Sequences_of_MHA">https://code.google.com/p/mysql-master-ha/wiki/Sequences_of_MHA</a></p>

<h5><span id="t3">三.MHA适用的主从架构</span> <br></h5>

<p><a href="https://code.google.com/p/mysql-master-ha/wiki/UseCases">https://code.google.com/p/mysql-master-ha/wiki/UseCases</a></p>

<h5><span id="t4">四.MHA高可用环境的构建</span><br></h5>

<h5><span id="t5">4.1 实验环境</span></h5>

<p><img src="http://geekwolf.github.io/images/mysql/ar.png" alt="" /></p>

<ul>
<li>Node1:192.168.10.216 (主)</li>
<li>Node2:192.168.10.217 (从,主故障切换的备主)</li>
<li>Node3:192.168.10.218 (从,兼MHA管理节点)</li>
<li>VIP : 192.168.10.219</li>
<li>Mysql:Percona-Server-5.6.16-rel64.2-569</li>
<li>以上节点系统均为CentOS6.5 x64</li>
</ul>


<h5><span id="t6">4.2 实验大概步骤</span></h5>

<ol type="a">
<li>三节点配置epel的yum源，安装相关依赖包<br></li>
<li>建立主从复制关系<br></li>
<li>ssh-keygen实现三台机器之间相互免密钥登录 <br></li>
<li>三节点安装mha4mysql-node-0.56,node3上安装mha4mysql-manager-0.56 <br></li>
<li>在node3上管理MHA配置文件<br></li>
<li>masterha_check_ssh验证ssh信任登录是否成功,masterha_check_repl验证mysql复制是否成功<br></li>
<li>启动MHA manager，并监控日志文件<br></li>
<li>测试master(Node1)的mysql宕掉后，是否会自动切换正常<br>
I . 配置VIP，切换后从自动接管主服务，并对客户端透明<br></li>
</ol>


<h5><span id="t7">4.3 脚本相关说明</span></h5>

<p>MHA node有三个脚本，依赖perl模块<br>
save_binary_logs：保存和拷贝宕掉的主服务器二进制日志 <br>
apply_diff_relay_logs:识别差异的relay log事件，并应用到所有从服务器节点 <br>purge_relay_logs:清除relay log日志文件<br></p>

<h5><span id="t8">4.4 MHA部署过程</span></h5>

<p><strong>A.</strong>三节点配置epel的yum源，安装相关依赖包</p>

<pre><code>rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
yum  -y install perl-DBD-MySQL  ncftp
</code></pre>

<p><strong>B.</strong> 建立主从复制关系</p>

<p>在node1上：</p>

<pre><code>mysql&gt;grant replication slave  on *.* to 'rep'@'192.168.10.%' identified by 'geekwolf';
mysql&gt;grant all on *.* to 'root'@'192.168.10.%' identified by 'geekwolf';
mysql&gt;show master status;
</code></pre>

<p>拷贝node1的data目录同步到node2，node3
在node2 node3上：</p>

<pre><code>mysql&gt;change master  to  master_host='192.168.10.216', master_user='rep', master_password='geekwolf',master_port=3306, master_log_file='mysql-in.000006',master_log_pos=120,master_connect_retry=1;
mysql&gt;start slave;
</code></pre>

<p>每个节点都做好mysql命令的软链</p>

<p><code>ln -s /usr/local/mysql/bin/* /usr/local/bin/</code></p>

<p><strong>C.</strong> ssh-keygen实现三台机器之间相互免密钥登录
在node1(在其他两个节点一同)执行</p>

<pre><code>ssh-keygen -t rsa 
ssh-copy-id -i /root/.ssh/id_rsa.pub root@node1 
ssh-copy-id -i /root/.ssh/id_rsa.pub root@node2 
ssh-copy-id -i /root/.ssh/id_rsa.pub root@node3
</code></pre>

<p><strong>D.</strong> 三节点安装mha4mysql-node-0.56,node3上安装mha4mysql-manager-0.56 <br>
在node1 node2 node3安装mha4mysql-node <br>
wget <a href="https://googledrive.com/host/0B1lu97m8-haWeHdGWXp0YVVUSlk/mha4mysql-node-0.56.tar.gz">https://googledrive.com/host/0B1lu97m8-haWeHdGWXp0YVVUSlk/mha4mysql-node-0.56.tar.gz</a><br>
tar xf mha4mysql-node-0.56.tar.gz <br>
cd mha4mysql-node <br>
perl Makefile.PL <br>
make &amp;&amp; make install<br></p>

<p>在node3上安装mha4mysql-manager<br>
wget <a href="https://googledrive.com/host/0B1lu97m8-haWeHdGWXp0YVVUSlk/mha4mysql-manager-0.56.tar.gz">https://googledrive.com/host/0B1lu97m8-haWeHdGWXp0YVVUSlk/mha4mysql-manager-0.56.tar.gz</a><br>
tar xf mha4mysql-manager-0.56.tar.gz <br>
cd mha4mysql-manager-0.56 <br>
yum install perl-DBD-MySQL perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-Config-IniFiles perl-Time-HiRes</p>

<p><strong>E.</strong> 在node3上管理MHA配置文件 <br>
mkdir -p /etc/mha/{app1,scripts} <br>
cp mha4mysql-manager-0.56/samples/conf/<em> /etc/mha/ <br>
cp mha4mysql-manager-0.56/samples/scripts/</em> /etc/mha/scripts/ <br>
mv /etc/mha/app1.cnf /etc/mha/app1/ <br>
mv /etc/mha/masterha_default.cnf /etc/masterha_default.cnf<br></p>

<p>设置全局配置： <br>
vim /etc/mha/masterha_default.cnf</p>

<pre><code>[server default]
user=root
password=geekwolf
ssh_user=root
repl_user=rep
repl_password=geekwolf
ping_interval=1
#shutdown_script=""
secondary_check_script = masterha_secondary_check -s node1 -s node2 -s node3 --user=root --master_host=node1 --master_ip=192.168.10.216 --master_port=3306
#master_ip_failover_script="/etc/mha/scripts/master_ip_failover"
#master_ip_online_change_script="/etc/mha/scripts/master_ip_online_change"
# shutdown_script= /script/masterha/power_manager
#report_script=""
</code></pre>

<p>vim /etc/mha/app1/app1.cnf</p>

<pre><code>[server default] 
manager_workdir=/var/log/mha/app1
manager_log=/var/log/mha/app1/manager.log
[server1] 
hostname=node1
master_binlog_dir="/usr/local/mysql/logs"
candidate_master=1
[server2]
hostname=node2
master_binlog_dir="/usr/local/mysql/logs"
candidate_master=1
[server3]
hostname=node3
master_binlog_dir="/usr/local/mysql/logs"
no_master=1
</code></pre>

<p><strong>注释：</strong> <br>
&emsp;&emsp;candidate_master=1 表示该主机优先可被选为new master，当多个[serverX]等设置此参数时，优先级由[serverX]配置的顺序决定 <br>
&emsp;&emsp;secondary_check_script mha强烈建议有两个或多个网络线路检查MySQL主服务器的可用性。默认情况下,只有单一的路线 MHA Manager检查:从Manager to Master,但这是不可取的。MHA实际上可以有两个或两个以上的检查路线通过调用外部脚本定义二次检查脚本参数<br>
&emsp;&emsp;master_ip_failover_script 在MySQL从服务器提升为新的主服务器时，调用此脚本，因此可以将vip信息写到此配置文件 <br>
&emsp;&emsp;master_ip_online_change_script 使用masterha_master_switch命令手动切换MySQL主服务器时后会调用此脚本，参数和master_ip_failover_script 类似，脚本可以互用
&emsp;&emsp;shutdown_script 此脚本(默认samples内的脚本)利用服务器的远程控制IDRAC等，使用ipmitool强制去关机，以避免fence设备重启主服务器，造成脑列现象 <br>
&emsp;&emsp;report_script 当新主服务器切换完成以后通过此脚本发送邮件报告，可参考使用 <a href="http://caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz">http://caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz</a><br>
&emsp;&emsp;以上涉及到的脚本可以从mha4mysql-manager-0.56/samples/scripts/*拷贝进行修改使用 <br>
&emsp;&emsp;其他manager详细配置参数<a href="https://code.google.com/p/mysql-master-ha/wiki/Parameters">https://code.google.com/p/mysql-master-ha/wiki/Parameters</a><br></p>

<p><strong>F.</strong> masterha_check_ssh验证ssh信任登录是否成功,masterha_check_repl验证mysql复制是否成功 <br>
验证ssh信任：masterha_check_ssh &mdash;conf=/etc/mha/app1/app1.cnf</p>

<pre><code>[root@localhost ~]# masterha_check_ssh --conf=/etc/mha/app1/app1.cnf
Tue May 13 07:53:15 2014 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Tue May 13 07:53:15 2014 - [info] Reading application default configuration from /etc/mha/app1/app1.cnf..
Tue May 13 07:53:15 2014 - [info] Reading server configuration from /etc/mha/app1/app1.cnf..
Tue May 13 07:53:15 2014 - [info] Starting SSH connection tests..
Tue May 13 07:53:16 2014 - [debug]
Tue May 13 07:53:15 2014 - [debug] Connecting via SSH from root@node1(192.168.10.216:22) to root@node2(192.168.10.217:22)..
Tue May 13 07:53:15 2014 - [debug] ok.
Tue May 13 07:53:15 2014 - [debug] Connecting via SSH from root@node1(192.168.10.216:22) to root@node3(192.168.10.218:22)..
Tue May 13 07:53:16 2014 - [debug] ok.
Tue May 13 07:53:16 2014 - [debug]
Tue May 13 07:53:16 2014 - [debug] Connecting via SSH from root@node2(192.168.10.217:22) to root@node1(192.168.10.216:22)..
Tue May 13 07:53:16 2014 - [debug] ok.
Tue May 13 07:53:16 2014 - [debug] Connecting via SSH from root@node2(192.168.10.217:22) to root@node3(192.168.10.218:22)..
Tue May 13 07:53:16 2014 - [debug] ok.
Tue May 13 07:53:17 2014 - [debug]
Tue May 13 07:53:16 2014 - [debug] Connecting via SSH from root@node3(192.168.10.218:22) to root@node1(192.168.10.216:22)..
Tue May 13 07:53:16 2014 - [debug] ok.
Tue May 13 07:53:16 2014 - [debug] Connecting via SSH from root@node3(192.168.10.218:22) to root@node2(192.168.10.217:22)..
Tue May 13 07:53:17 2014 - [debug] ok.
Tue May 13 07:53:17 2014 - [info] All SSH connection tests passed successfully.
</code></pre>

<p>验证主从复制：masterha_check_repl &mdash;conf=/etc/mha/app1/app1.cnf</p>

<pre><code>[root@localhost mha]# masterha_check_repl --conf=/etc/mha/app1/app1.cnf
Tue May 13 08:10:54 2014 - [info] Reading default configuration from /etc/masterha_default.cnf..
Tue May 13 08:10:54 2014 - [info] Reading application default configuration from /etc/mha/app1/app1.cnf..
Tue May 13 08:10:54 2014 - [info] Reading server configuration from /etc/mha/app1/app1.cnf..
Tue May 13 08:10:54 2014 - [info] MHA::MasterMonitor version 0.56.
Tue May 13 08:10:54 2014 - [info] GTID failover mode = 0
Tue May 13 08:10:54 2014 - [info] Dead Servers:
Tue May 13 08:10:54 2014 - [info] Alive Servers:
Tue May 13 08:10:54 2014 - [info] node1(192.168.10.216:3306)
Tue May 13 08:10:54 2014 - [info] node2(192.168.10.217:3306)
Tue May 13 08:10:54 2014 - [info] node3(192.168.10.218:3306)
Tue May 13 08:10:54 2014 - [info] Alive Slaves:
Tue May 13 08:10:54 2014 - [info] node2(192.168.10.217:3306) Version=5.6.16-64.2-rel64.2-log (oldest major version between slaves) log-bin:enabled
Tue May 13 08:10:54 2014 - [info] Replicating from 192.168.10.216(192.168.10.216:3306)
Tue May 13 08:10:54 2014 - [info] Primary candidate for the new Master (candidate_master is set)
Tue May 13 08:10:54 2014 - [info] node3(192.168.10.218:3306) Version=5.6.16-64.2-rel64.2-log (oldest major version between slaves) log-bin:enabled
Tue May 13 08:10:54 2014 - [info] Replicating from 192.168.10.216(192.168.10.216:3306)
Tue May 13 08:10:54 2014 - [info] Not candidate for the new Master (no_master is set)
Tue May 13 08:10:54 2014 - [info] Current Alive Master: node1(192.168.10.216:3306)
Tue May 13 08:10:54 2014 - [info] Checking slave configurations..
Tue May 13 08:10:54 2014 - [info] read_only=1 is not set on slave node2(192.168.10.217:3306).
Tue May 13 08:10:54 2014 - [warning] relay_log_purge=0 is not set on slave node2(192.168.10.217:3306).
Tue May 13 08:10:54 2014 - [info] read_only=1 is not set on slave node3(192.168.10.218:3306).
Tue May 13 08:10:54 2014 - [warning] relay_log_purge=0 is not set on slave node3(192.168.10.218:3306).
Tue May 13 08:10:54 2014 - [info] Checking replication filtering settings..
Tue May 13 08:10:54 2014 - [info] binlog_do_db= , binlog_ignore_db=
Tue May 13 08:10:54 2014 - [info] Replication filtering check ok.
Tue May 13 08:10:54 2014 - [info] GTID (with auto-pos) is not supported
Tue May 13 08:10:54 2014 - [info] Starting SSH connection tests..
Tue May 13 08:10:55 2014 - [info] All SSH connection tests passed successfully.
Tue May 13 08:10:55 2014 - [info] Checking MHA Node version..
Tue May 13 08:10:55 2014 - [info] Version check ok.
Tue May 13 08:10:55 2014 - [info] Checking SSH publickey authentication settings on the current master..
Tue May 13 08:10:56 2014 - [info] HealthCheck: SSH to node1 is reachable.
Tue May 13 08:10:56 2014 - [info] Master MHA Node version is 0.56.
Tue May 13 08:10:56 2014 - [info] Checking recovery script configurations on node1(192.168.10.216:3306)..
Tue May 13 08:10:56 2014 - [info] Executing command: save_binary_logs --command=test --start_pos=4 --binlog_dir=/usr/local/mysql/logs --output_file=/var/tmp/save_binary_logs_test --manager_version=0.56 --start_file=mysql-bin.000009
Tue May 13 08:10:56 2014 - [info] Connecting to root@192.168.10.216(node1:22)..
  Creating /var/tmp if not exists.. ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /usr/local/mysql/logs, up to mysql-bin.000009
Tue May 13 08:10:56 2014 - [info] Binlog setting check done.
Tue May 13 08:10:56 2014 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..
Tue May 13 08:10:56 2014 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user='root' --slave_host=node2 --slave_ip=192.168.10.217 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.16-64.2-rel64.2-log --manager_version=0.56 --relay_log_info=/usr/local/mysql/data/relay-log.info --relay_dir=/usr/local/mysql/data/ --slave_pass=xxx
Tue May 13 08:10:56 2014 - [info] Connecting to root@192.168.10.217(node2:22)..
  Checking slave recovery environment settings..
    Opening /usr/local/mysql/data/relay-log.info ... ok.
    Relay log found at /usr/local/mysql/logs, up to relay-bin.000006
    Temporary relay log file is /usr/local/mysql/logs/relay-bin.000006
    Testing mysql connection and privileges..Warning: Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Tue May 13 08:10:57 2014 - [info] Executing command : apply_diff_relay_logs --command=test --slave_user='root' --slave_host=node3 --slave_ip=192.168.10.218 --slave_port=3306 --workdir=/var/tmp --target_version=5.6.16-64.2-rel64.2-log --manager_version=0.56 --relay_log_info=/usr/local/mysql/data/relay-log.info --relay_dir=/usr/local/mysql/data/ --slave_pass=xxx
Tue May 13 08:10:57 2014 - [info] Connecting to root@192.168.10.218(node3:22)..
  Checking slave recovery environment settings..
    Opening /usr/local/mysql/data/relay-log.info ... ok.
    Relay log found at /usr/local/mysql/logs, up to relay-bin.000006
    Temporary relay log file is /usr/local/mysql/logs/relay-bin.000006
    Testing mysql connection and privileges..Warning: Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Tue May 13 08:10:57 2014 - [info] Slaves settings check done.
Tue May 13 08:10:57 2014 - [info]
node1(192.168.10.216:3306) (current master)
 +--node2(192.168.10.217:3306)
 +--node3(192.168.10.218:3306)
Tue May 13 08:10:57 2014 - [info] Checking replication health on node2..
Tue May 13 08:10:57 2014 - [info] ok.
Tue May 13 08:10:57 2014 - [info] Checking replication health on node3..
Tue May 13 08:10:57 2014 - [info] ok.
Tue May 13 08:10:57 2014 - [warning] master_ip_failover_script is not defined.
Tue May 13 08:10:57 2014 - [warning] shutdown_script is not defined.
Tue May 13 08:10:57 2014 - [info] Got exit code 0 (Not master dead).
MySQL Replication Health is OK.
</code></pre>

<p><strong>G.</strong> 启动MHA manager，并监控日志文件<br>
在node1上killall mysqld的同时在node3上启动manager服务</p>

<pre><code>[root@localhost mha]# masterha_manager --conf=/etc/mha/app1/app1.cnf
Tue May 13 08:19:01 2014 - [info] Reading default configuration from /etc/masterha_default.cnf..
Tue May 13 08:19:01 2014 - [info] Reading application default configuration from /etc/mha/app1/app1.cnf..
Tue May 13 08:19:01 2014 - [info] Reading server configuration from /etc/mha/app1/app1.cnf..
  Creating /var/tmp if not exists.. ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /usr/local/mysql/logs, up to mysql-bin.000009
Tue May 13 08:19:18 2014 - [info] Reading default configuration from /etc/masterha_default.cnf..
Tue May 13 08:19:18 2014 - [info] Reading application default configuration from /etc/mha/app1/app1.cnf..
Tue May 13 08:19:18 2014 - [info] Reading server configuration from /etc/mha/app1/app1.cnf..
</code></pre>

<p>&emsp;&emsp;之后观察node3上/var/log/mha/app1/manager.log日志会发现node1 dead状态，主自动切换到node2上，而node3上的主从配置指向了node2，并且发生一次切换后会生成/var/log/mha/app1/app1.failover.complete文件；<br>
<strong>手动恢复node1操作：</strong> <br>
&emsp;&emsp;rm -rf /var/log/mha/app1/app1.failover.complete<br>
&emsp;&emsp;启动node1上的mysql，重新配置node2 node3 主从指向node1（change master to）<br>
<strong>MHA Manager后台执行：</strong> <br>
nohup masterha_manager &mdash;conf=/etc/mha/app1/app1.cnf &lt; /dev/null > /var/log/mha/app1/app1.log 2>&amp;1 &amp;
守护进程方式参考：
<a href="https://code.google.com/p/mysql-master-ha/wiki/Runnning_Background">https://code.google.com/p/mysql-master-ha/wiki/Runnning_Background</a><br>
<a href="ftp://ftp.pbone.net/mirror/ftp5.gwdg.de/pub/opensuse/repositories/home:/weberho:/qmailtoaster/openSUSE_Tumbleweed/x86_64/daemontools-0.76-5.3.x86_64.rpm">ftp://ftp.pbone.net/mirror/ftp5.gwdg.de/pub/opensuse/repositories/home:/weberho:/qmailtoaster/openSUSE_Tumbleweed/x86_64/daemontools-0.76-5.3.x86_64.rpm</a></p>

<h5><span id="t9">4.5 配置VIP的方式</span></h5>

<p><strong>A.</strong>通过全局配置文件实现 <br>
vim /etc/mha/masterha_default.cnf</p>

<pre><code>[server default]
  user=root
  password=geekwolf
  ssh_user=root
  repl_user=rep
  repl_password=geekwolf
  ping_interval=1
  secondary_check_script = masterha_secondary_check -s node1 -s node2 -s node3 --user=root --master_host=node1 --master_ip=192.168.10.216 --master_port=3306
  master_ip_failover_script="/etc/mha/scripts/master_ip_failover"
  master_ip_online_change_script="/etc/mha/scripts/master_ip_online_change"
  #shutdown_script= /script/masterha/power_manager
  #report_script=""
</code></pre>

<p>修改后的master_ip_failover、master_ip_online_change脚本</p>

<pre><code>#!/usr/bin/env perl
use strict;
use warnings FATAL =&gt; 'all';
use Getopt::Long;
my (
    $command, $ssh_user, $orig_master_host, $orig_master_ip,
    $orig_master_port, $new_master_host, $new_master_ip, $new_master_port
);
my $vip = '192.168.10.218'; # Virtual IP
my $gateway = '192.168.10.1';#Gateway IP
my $interface = 'eth0'
my $key = "1";
my $ssh_start_vip = "/sbin/ifconfig $interface:$key $vip;/sbin/arping -I $interface -c 3 -s $vip $gateway &gt;/dev/null 2&gt;&amp;1";
my $ssh_stop_vip = "/sbin/ifconfig $interface:$key down";
GetOptions(
    'command=s' =&gt; \$command,
    'ssh_user=s' =&gt; \$ssh_user,
    'orig_master_host=s' =&gt; \$orig_master_host,
    'orig_master_ip=s' =&gt; \$orig_master_ip,
    'orig_master_port=i' =&gt; \$orig_master_port,
    'new_master_host=s' =&gt; \$new_master_host,
    'new_master_ip=s' =&gt; \$new_master_ip,
    'new_master_port=i' =&gt; \$new_master_port,
);
exit &amp;main();
sub main {
    print "\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n";
    if ( $command eq "stop" || $command eq "stopssh" ) {
        # $orig_master_host, $orig_master_ip, $orig_master_port are passed.
        # If you manage master ip address at global catalog database,
        # invalidate orig_master_ip here.
        my $exit_code = 1;
        eval {
            print "Disabling the VIP on old master: $orig_master_host \n";
            &amp;stop_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn "Got Error: $@\n";
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "start" ) {
        # all arguments are passed.
        # If you manage master ip address at global catalog database,
        # activate new_master_ip here.
        # You can also grant write access (create user, set read_only=0, etc) here.
        my $exit_code = 10;
        eval {
            print "Enabling the VIP - $vip on the new master - $new_master_host \n";
            &amp;start_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn $@;
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "status" ) {
        print "Checking the Status of the script.. OK \n";
        `ssh $ssh_user\@cluster1 \" $ssh_start_vip \"`;
        exit 0;
    }
    else {
        &amp;usage();
        exit 1;
    }
}
# A simple system call that enable the VIP on the new master
sub start_vip() {
    `ssh $ssh_user\@$new_master_host \" $ssh_start_vip \"`;
}
# A simple system call that disable the VIP on the old_master
sub stop_vip() {
    `ssh $ssh_user\@$orig_master_host \" $ssh_stop_vip \"`;
}
sub usage {
    print
    "Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n";
}
</code></pre>

<p><strong>B.</strong>通过第三方HA（keepalived、heartbeat）实现VIP，以keepalived为例 <br>
以node1 node2互为主备进行配置keepalived <br>
在node1 node2上分别下载安装keepalived <br>
wget <a href="http://www.keepalived.org/software/keepalived-1.2.13.tar.gz">http://www.keepalived.org/software/keepalived-1.2.13.tar.gz</a> <br>
yum -y install popt-* <br>
./configure &mdash;prefix=/usr/local/keepalived &mdash;enable-snmp <br>
make &amp;&amp; make install <br>
cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/ <br>
cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/<br>
chmod +x /etc/rc.d/init.d/keepalived <br>
chkconfig keepalived on <br>
mkdir /etc/keepalived <br>
ln -s /usr/local/keepalived/sbin/keepalived /usr/sbin<br></p>

<p>修改node1(192.168.10.216)配置文件 <br>
vim /etc/keepalived/keepalived.conf</p>

<pre><code>! Configuration File for keepalived
global_defs {
 router_id MHA 
 notification_email {
 root@localhost   #接收邮件，可以有多个，一行一个
}
 #当主、备份设备发生改变时，通过邮件通知
 notification_email_from  m@localhost
 #发送邮箱服务器
 smtp_server 127.0.0.1
 #发送邮箱超时时间
 smtp_connect_timeout 30
 }

varrp_script check_mysql {
     script "/etc/keepalived/check_mysql.sh"
}
vrrp_sync_group VG1 {
    group {
          VI_1
    }
notify_master "/etc/keepalived/master.sh"
}

vrrp_instance VI_1 {
     state master     
     interface eth0   
     virtual_router_id 110
     priority 100            
     advert_int 1
     nopreempt #不抢占资源，意思就是它活了之后也不会再把主抢回来

     authentication {
     # 认证方式，可以是PASS或AH两种认证方式
     auth_type PASS
     # 认证密码
     auth_pass geekwolf
     }
track_script {
     check_mysql
}
virtual_ipaddress {
     192.168.10.219
     }

}
</code></pre>

<p>修改node2(192.168.10.217)配置文件 <br>
vim /etc/keepalived/keepalived.conf</p>

<pre><code>! Configuration File for keepalived
global_defs {
 router_id MHA 
 notification_email {
 root@localhost   #接收邮件，可以有多个，一行一个
}
 #当主、备份设备发生改变时，通过邮件通知
 notification_email_from  m@localhost
 #发送邮箱服务器
 smtp_server 127.0.0.1
 #发送邮箱超时时间
 smtp_connect_timeout 30
 }

varrp_script check_mysql {
     script "/etc/keepalived/check_mysql.sh"
}
vrrp_sync_group VG1 {
    group {
          VI_1
    }
notify_master "/etc/keepalived/master.sh"
}
vrrp_instance VI_1 {
     state backup    
     interface eth0    
     virtual_router_id 110
     priority 99            
     advert_int 1

     authentication {
     # 认证方式，可以是PASS或AH两种认证方式
     auth_type PASS
     # 认证密码
     auth_pass geekwolf
     }
track_script {
     check_mysql
}
virtual_ipaddress {
     192.168.10.219
     }

}
</code></pre>

<p>check_mysql.sh</p>

<pre><code>#!/bin/bash
MYSQL=/usr/local/mysql/bin/mysql
MYSQL_HOST=127.0.0.1
MYSQL_USER=root
MYSQL_PASSWORD=geekwolf
CHECK_TIME=3
#mysql  is working MYSQL_OK is 1 , mysql down MYSQL_OK is 0
MYSQL_OK=1
function check_mysql_helth (){
$MYSQL -h $MYSQL_HOST -u $MYSQL_USER -e "show status;" &gt;/dev/null 2&gt;&amp;1
if [ $? = 0 ] ;then
     MYSQL_OK=1
else
     MYSQL_OK=0
fi
     return $MYSQL_OK
}
while [ $CHECK_TIME -ne 0 ]
do
     let "CHECK_TIME -= 1"
     check_mysql_helth
if [ $MYSQL_OK = 1 ] ; then
     CHECK_TIME=0
     exit 0
fi
if [ $MYSQL_OK -eq 0 ] &amp;&amp;  [ $CHECK_TIME -eq 0 ]
then
     pkill keepalived
exit 1
fi
sleep 1
done
</code></pre>

<p>master.sh</p>

<pre><code>#!/bin/bash
VIP=192.168.10.219
GATEWAY=1.1
/sbin/arping -I eth0 -c 5 -s $VIP $GATEWAY &amp;&gt;/dev/null
</code></pre>

<p>chmod +x /etc/keepalived/check_mysql.sh <br>
chmod +x /etc/keepalived/master.sh</p>

<h5><span id="t10">五.MHA常用命令</span></h5>

<p>查看manager状态 <br>
masterha_check_status &mdash;conf=/etc/mha/app1/app1.cnf</p>

<p>查看免密钥是否正常 <br>
masterha_check_ssh &mdash;conf=/etc/mha/app1/app1.cnf</p>

<p>查看主从复制是否正常 <br>
masterha_check_repl &mdash;conf=/etc/mha/app1/app1.cnf</p>

<p>添加新节点server4到配置文件 <br>
masterha_conf_host &mdash;command=add &mdash;conf=/etc/mha/app1/app1.cnf &mdash;hostname=geekwolf &mdash;block=server4 &mdash;params=&ldquo;no_master=1;ignore_fail=1&rdquo;
删除server4节点 <br>
masterha_conf_host &mdash;command=delete &mdash;conf=/etc/mha/app1/app1.cnf &mdash;block=server4</p>

<p><strong>注：</strong> <br>
block:为节点区名，默认值 为[server_$hostname],如果设置成block=100，则为[server100]
params:参数，分号隔开(参考<a href="https://code.google.com/p/mysql-master-ha/wiki/Parameters">https://code.google.com/p/mysql-master-ha/wiki/Parameters</a>)</p>

<p>关闭manager服务 <br>
masterha_stop &mdash;conf=/etc/mha/app1/app1.cnf</p>

<p>主手动切换(前提不要启动masterha_manager服务) <br>
在主node1存活情况下进行切换 <br>
交互模式： <br>
masterha_master_switch &mdash;master_state=alive &mdash;conf=/etc/mha/app1/app1.cnf &mdash;new_master_host=node2 <br>
非交互模式： <br>
masterha_master_switch &mdash;master_state=alive &mdash;conf=/etc/mha/app1/app1.cnf &mdash;new_master_host=node2 &mdash;interactive=0 <br>
在主node1宕掉情况下进行切换 <br>
masterha_master_switch &mdash;master_state=dead &mdash;conf=/etc/mha/app1/app1.cnf &mdash;dead_master_host=node1 &mdash;dead_master_ip=192.168.10.216 &mdash;dead_master_port=3306 &mdash;new_master_host=192.168.10.217
详细请参考:<a href="https://code.google.com/p/mysql-master-ha/wiki/TableOfContents?tm=6">https://code.google.com/p/mysql-master-ha/wiki/TableOfContents?tm=6</a>
*</p>

<h5><span id="t11">六.注意事项</span> <br></h5>

<p><strong>A.</strong> 以上两种vip切换方式，建议采用第一种方法 <br>
<strong>B.</strong> 发生主备切换后，manager服务会自动停掉，且在/var/log/mha/app1下面生成<br>app1.failover.complete，若再次发生切换需要删除app1.failover.complete文件<br>
<strong>C.</strong> 测试过程发现一主两从的架构(两从都设置可以担任主角色candidate_master=1)，当旧主故障迁移到备主后，删除app1.failover.complete，再次启动manager，停掉新主后，发现无法正常切换(解决方式：删除/etc/mha/app1/app1.cnf里面的旧主node1的信息后，重新切换正常) <br>
<strong>D.</strong> arp缓存导致切换VIP后，无法使用问题 <br>
<strong>E.</strong> 使用Semi-Sync能够最大程度保证数据安全<br>
<strong>F.</strong> Purge_relay_logs脚本删除中继日志不会阻塞SQL线程，在每台从节点上设置计划任务定期清除中继日志<br>
&emsp;&emsp;0 5 * * * root /usr/bin/purge_relay_logs &mdash;user=root &mdash;password=geekwolf &mdash;disable_relay_log_purge >> /var/log/mha/purge_relay_logs.log 2>&amp;1</p>

<h5><span id="t12">七.部署过程遇到的问题</span></h5>

<p><strong>问题1：</strong>
[root@node1 mha4mysql-node-0.56]# perl Makefile.PL <br>
Can&rsquo;t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: inc /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at inc/Module/Install/Makefile.pm line 4.  <br>
BEGIN failed&mdash;compilation aborted at inc/Module/Install/Makefile.pm line 4.
Compilation failed in require at inc/Module/Install.pm line 283.  <br>
Can&rsquo;t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: inc /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/ <br>vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at inc/Module/Install/Can.pm line 6.  <br>
BEGIN failed&mdash;compilation aborted at inc/Module/Install/Can.pm line 6.  <br>
Compilation failed in require at inc/Module/Install.pm line 283.  <br>
Can&rsquo;t locate ExtUtils/MM_Unix.pm in @INC (@INC contains: inc /usr/local/lib64/ <br>perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at inc/Module/Install/ <br>Metadata.pm line 349.  <br>
<strong>解决办法：</strong>  <br>
yum -y install perl-CPAN perl-devel perl-DBD-MySQL</p>

<p><strong>问题2：</strong>  <br>
Can&rsquo;t locate Time/HiRes.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at /usr/local/share/perl5/MHA/SSHCheck.pm line 28.  <br>
BEGIN failed&mdash;compilation aborted at /usr/local/share/perl5/MHA/SSHCheck.pm line 28.  <br>
Compilation failed in require at /usr/local/bin/masterha_check_ssh line 25.
BEGIN failed&mdash;compilation aborted at /usr/local/bin/masterha_check_ssh line 25. <br>
<strong>解决办法</strong>：  <br>
yum -y install perl-Time-HiRes</p>

<p><strong>问题3：</strong>
<img src="http://geekwolf.github.io/images/mysql/mhaq.jpg" alt="" />
<strong>解决办法:</strong> <br>
每个节点都做好mysql命令的软链 <br>
ln -s /usr/local/mysql/bin/* /usr/local/bin/<br></p>

<p><strong>参考文档：</strong></p>

<blockquote><p><a href="https://code.google.com/p/mysql-master-ha">https://code.google.com/p/mysql-master-ha</a> <br>
<a href="http://blog.chinaunix.net/uid-28437434-id-3476641.html">http://blog.chinaunix.net/uid-28437434-id-3476641.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[存储引擎介绍及适用场景]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/23/cun-chu-yin-qing-jie-shao-ji-gua-yong-chang-jing/"/>
    <updated>2014-04-23T14:05:56+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/23/cun-chu-yin-qing-jie-shao-ji-gua-yong-chang-jing</id>
    <content type="html"><![CDATA[<p>查看当前的默认存储引擎<br>
<code>  show variables  like 'table_type';</code></p>

<p>查看当前数据库支持的引擎<br>
<code>   show engines \G;</code><br>
<code>   show variables like 'have%';</code></p>

<!--more-->


<p>创建表时指定存储引擎<br>
<code>   create table ai (i bigint(20) not null auto_increment,primary key(i));</code><br></p>

<p>修改表引擎<br>
<code>  alter table ai engine=innodb;</code></p>

<p><strong>常见Mysql数据库引擎对比：</strong></p>

<p><img src="/images/mysql/engines.png" alt="" /></p>

<h5>一、MyISAM引擎特点：<br></h5>

<p>在磁盘存储成3个文件，文件名和表名一样，但扩展名分别为：<br>
.frm        (存储表定义)<br>
.MYD     （MYData，存储数据）<br>
.MYI       （MYIndex，存储索引）<br>
其中数据文件和索引文件可以分开在不同目录，平均分布IO</p>

<p>创建表时指定数据和索引路径：<br></p>

<p><code>create table geekwolf (id int,c varchar(10)) data directory='/data/data/' index directory='/data/index' engine='MyISAM';</code></p>

<p>MyISAM的表可能出现损坏的解决办法：<br>
check table geekwolf；检查表的健康情况<br>
repair table geekwolf；修改表<br></p>

<p>MyISAM的表引擎支持3种不同的存储格式：<br>
<strong>静态表</strong>（默认格式，固定长度，存储时按照列宽度定义补足空格；在查询时会丢失尾部的空格）<br>
<strong>动态表</strong>（频繁更新删除记录会产生碎片，占用空间相对较少，需要定期执行optimize table 或myisamchk -r来改善性能）<br>
<strong>压缩表</strong> （由myisampack工具创建）<br></p>

<p><strong>适用场景：</strong><br>
以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高的场景</p>

<h5>二、INNODB引擎特点：<br></h5>

<p><strong>1.自动增长列：</strong><br></p>

<pre><code>InnoDB表，自动增长列必须是索引，如果是组合索引，必须是组合索引的第一列；&lt;br&gt;
对于MyISAM引擎表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面激烈进行排序后递增的&lt;br&gt;
创建MyISAM表autoincre_demo&lt;br&gt;
</code></pre>

<p><code>    create table autoincre_demo (d1 smallint not null auto_increment,d2 smallint not null,name varchar(10),index(d2.d1)) engine=myisam;</code></p>

<p>如图所示：自动增长列是d1作为组合索引的第二列,插入记录后，发现增长列是按照组合索引的第一列d2进行排序后递增的</p>

<p><img src="/images/mysql/autoincre.png" alt="" /><br></p>

<p><strong>2.外键约束：</strong>
  Innodb引擎支持外键，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引<br>
  外键信息可以通过show table status like &lsquo;test&rsquo; \G;  show create table &lsquo;test&rsquo;;<br></p>

<p><strong>3.存储方式：</strong><br>
<strong>A.</strong> 使用共享表空间，这种方式创建的表结果保存在.frm文件，数据和索引保存在innodb_data_home_dir innodb_data_file_path定义的表空间中<br>
<strong>B.</strong>多表空间存储，表结构保存在.frm文件中，但是每个表的数据和索引单独存放在.ibd中；每个分区对于单独的.ibd<br>
   （需要开启innodb_file_per_table=1）<br>
 对于使用多表空间的表可以方便进行单表备份恢复，简单复制ibd和frm文件的方法因没有共享表空间的字典信息，而无法使用；多表空间情况，因为Innodb把内部的数据字典和在线重做日志存放在共享表空间里面</p>

<p><strong>使用此语句删除.ibd文件：</strong><br>
<code>ALTER TABLE tbl_name DISCARD TABLESPACE;</code><br>
要把备份的.ibd文件还原到表中，需把此文件复制到数据库目录中，然后书写此语句：<br>
<code>ALTER TABLE tbl_name IMPORT TABLESPACE;</code></p>

<p><strong>适用场景：</strong><br>
需要事务处理，对事务的完整性要求高，并发条件下要求数据一致性的计费系统或者财务系统等对数据准心要求比较搞的系统（5.5+默认引擎）</p>

<h5>三、MEMORY引擎：</h5>

<p> <strong>A.</strong>每个MEMORY表实际对应一个磁盘文件.frm，数据存放在内存，默认采用HASH索引（也可以设置撑Btree索引），服务关闭数据会丢失<br>
 <strong>B.</strong>是否memory表中的内存可以通过delete from 或者truncate 或者drop table<br>
<strong>C.</strong>memory表可以放置数据量的大小受到max_heap_table_size变量约束，默认16M，在定义表时可以用MAX_ROWS指定表的最大行数<br>
<strong>D.</strong>使用环境：用于内容变化不频繁或者作为统计操作的中间结果表</p>

<p><strong>适用场景：</strong><br>
一般用于更新不太频繁的小表，用以快速得到访问结果的环境，但对表大小有限制</p>

<h5>四、TOKUDB引擎：<br></h5>

<p>   具有高压缩率高效的插入性能，支持大多数在线DDL<br>
   与InnoDB引擎对比测试：<a href="http://www.tokutek.com/resources/tokudb-vs-innodb/">http://www.tokutek.com/resources/tokudb-vs-innodb/</a><br>
   <strong>特性：</strong><br></p>

<pre><code>使用Fractal树索引保证了高效的插入性能
优秀的压缩特性，比InnoDB高近10倍
Hot Schema Changes特性支持在线创建索引和添加/删除属性列等DDL操作
使用Bulk Loader达到快速加载大数据量
提供主从延迟消除技术
支持ACID和MVCC
</code></pre>

<p><strong>适用场景：</strong><br>
日志数据，日志通常插入频繁切存储量大；<br>
历史数据，通常不会再有写操作，可以利用TokuDB的高压缩特性存储；<br>
在线DDL较频繁的场景，使用TokuDB可以大大增加系统可用性；</p>

<p><strong>注：</strong>
具体使用哪种引擎要根据自己的业务的特点去决定</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解MySQL运算符和常用内置函数]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/09/li-jie-mysqlyun-suan-fu/"/>
    <updated>2014-04-09T14:56:41+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/09/li-jie-mysqlyun-suan-fu</id>
    <content type="html"><![CDATA[<h5>一、MySQL中的运算符</h5>

<p><img src="/images/mysql/suanshu.png" alt="" /></p>

<p><img src="/images/mysql/lj.png" alt="" /></p>

<!--more-->


<p><strong>注意事项：<br>
1.在除法运算和模数运算中，如果除数是0，将是非法除数，结果返回NULL</strong><br>
&emsp;取模运算中，也可以用MOD(a,b)函数或者a%b</p>

<pre><code>mysql&gt; select 1/0, 100%0;
+------+-------+
| 1/0 | 100%0 |
+------+-------+
| NULL | NULL |
+------+-------+
1 row in set (0.01 sec)
mysql&gt; select 3%2,mod(3,2);
+------+----------+
| 3%2 | mod(3,2) |
+------+----------+
| 1 | 1 |
+------+----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>2.NULL只能用&lt;=>进行比较，其他的比较运算符时返回NULL</strong></p>

<pre><code>mysql&gt; select 'a'&lt;'b','a'&lt;'a',1&lt;2,null&lt;=&gt;null;
+---------+---------+-----+-------------+
| 'a'&lt;'b' | 'a'&lt;'a' | 1&lt;2 | null&lt;=&gt;null |
+---------+---------+-----+-------------+
| 1 | 0 | 1 | 1 |
+---------+---------+-----+-------------+
1 row in set (0.02 sec)
mysql&gt; select 'a'&lt;'b','a'&lt;'a',1&lt;2,null&lt;null;
+---------+---------+-----+-----------+
| 'a'&lt;'b' | 'a'&lt;'a' | 1&lt;2 | null&lt;null |
+---------+---------+-----+-----------+
| 1 | 0 | 1 | NULL |
+---------+---------+-----+-----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>3.BETWEEN IN</strong><br>
&emsp;between运算符使用“a BETWEEN min AND max”当a大于等于min并且小于等于max返回1，否则返回0
&emsp;IN运算符使用"a IN（values1,values2,&hellip;)&ldquo;，当a的值存在于列表中时，则郑鄂表达式返回值1，否则0</p>

<pre><code>mysql&gt; select 10 between 10 and 20,9 between 10 and 20;
+----------------------+---------------------+
| 10 between 10 and 20 | 9 between 10 and 20 |
+----------------------+---------------------+
| 1 | 0 |
+----------------------+---------------------+
1 row in set (0.00 sec)
mysql&gt; select 1 in(1,2,3),'t' in ('t','a','b','f'),0 in(1,2);
+-------------+--------------------------+-----------+
| 1 in(1,2,3) | 't' in ('t','a','b','f') | 0 in(1,2) |
+-------------+--------------------------+-----------+
| 1 | 1 | 0 |
+-------------+--------------------------+-----------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>4.REGEXP运算符格式"str REGEXP str_pat"</strong><br>
&emsp;当str字符串中含有str_pat相匹配的字符串时返回1，否则0</p>

<pre><code>mysql&gt; select 'abcdef' regexp 'ac','abcdef' regexp 'ab','abcdefg' regexp 'k';
+----------------------+----------------------+----------------------+
| 'abcdef' regexp 'ac' | 'abcdef' regexp 'ab' | 'abcdefg' regexp 'k' |
+----------------------+----------------------+----------------------+
| 0 | 1 | 0 |
+----------------------+----------------------+----------------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>5. 逻辑与AND和逻辑或OR</strong><br>
&emsp;AND：当所有操作数都为非零，并且不为NULL时，返回1；当一个或多个为0时，返回0；操作数任何一个为NULL，则返回NULL<br>
&emsp;OR   : 当两个操作数均为非NULL值时，如有任意一个为非零值，则返回1，否则0；<br>
&emsp;&emsp;&emsp; 当有一个操作数为NULL时，如另外一个为非0，则结果1，否则NULL;<br>
&emsp;&emsp;&emsp; 如果两个操作数均为NULL，则所得结果为NULL</p>

<pre><code>mysql&gt; select (1 and 1),(0 and 1),(3 and 1),(1 and null);
+-----------+-----------+-----------+--------------+
| (1 and 1) | (0 and 1) | (3 and 1) | (1 and null) |
+-----------+-----------+-----------+--------------+
| 1 | 0 | 1 | NULL |
+-----------+-----------+-----------+--------------+
1 row in set (0.00 sec)
mysql&gt; select (1 or 0),(0 or 0),(1 or null),(1 or 1),(null or null);
+----------+----------+-------------+----------+----------------+
| (1 or 0) | (0 or 0) | (1 or null) | (1 or 1) | (null or null) |
+----------+----------+-------------+----------+----------------+
| 1 | 0 | 1 | 1 | NULL |
+----------+----------+-------------+----------+----------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>6.位运算</strong><br>
&emsp;位与对多个操作数的二进制位做逻辑与操作<br></p>

<pre><code>mysql&gt; select bin(2);
+--------+
| bin(2) |
+--------+
| 10 |
+--------+
1 row in set (0.00 sec)
mysql&gt; select bin(3);
+--------+
| bin(3) |
+--------+
| 11 |
+--------+
1 row in set (0.00 sec)
mysql&gt; select bin(100);
+----------+
| bin(100) |
+----------+
| 1100100 |
+----------+
1 row in set (0.00 sec)
mysql&gt; select 2&amp;3&amp;100;
+---------+
| 2&amp;3&amp;100 |
+---------+
| 0 |
+---------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>7.位取反</strong><br>
&emsp;在MySQL中，常量数字默认会以8个字节来表示，8字节就是64位，常量1的二进制表示为63个0加1个1，位取反后就是63个1加1个0，转换成十进制后就是18446744073709551614</p>

<p><img src="/images/mysql/qf.png" alt="" /></p>

<p><strong>8.位右移</strong><br></p>

<p><img src="/images/mysql/wyy.png" alt="" /></p>

<h5>二、运算符的优先级</h5>

<p><img src="/images/mysql/yxj.png" alt="" /></p>

<h5>三、常用内置函数</h5>

<p><img src="/images/mysql/strfun.png" alt="" /></p>

<p><img src="/images/mysql/numfun.png" alt="" /></p>

<p><img src="/images/mysql/timefun.png" alt="" /></p>

<p><img src="/images/mysql/otherfun.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
date_format(date,fmt)fmt格式:<br>
<a href="http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-format">http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-format</a><br>
date_add(date,INTERVAL expr type) type类型：<br>
<a href="http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-add">http://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_date-add</a></p>

<blockquote><p><a href="http://dev.mysql.com/doc/refman/5.5/en/functions.html">http://dev.mysql.com/doc/refman/5.5/en/functions.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql支持的数据类型]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/08/mysqlzhi-chi-de-shu-ju-lei-xing/"/>
    <updated>2014-04-08T19:36:14+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/08/mysqlzhi-chi-de-shu-ju-lei-xing</id>
    <content type="html"><![CDATA[<h5>一、数值类型</h5>

<p><img src="/images/mysql/numbers.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
<strong>1. int类型里面默认的数据宽度是11，即int(11)</strong><br>
&emsp;关于zerofill，在数字位数不够的空间用字符0填充<br>
&emsp;例如：</p>

<p><img src="/images/mysql/n2.png" alt="" /></p>

<p><strong>2.整数类型有AUTO_INCREMENT的属性</strong><br>
&emsp;AUTO_INCREMENT的值一般从1开始，每行增加1，插入NULL到一个AUTO_INCREMENT列时，Mysql插入一个比该列中当前最大值大1的值<br>
&emsp;一个表中最多只能有一个AUTO_INCREMENT列<br>
&emsp;使用AUTO_INCREMENT的条件：<br>
&emsp;该列应该定义为NOT NULL，并且为PRIMARY KEY 或者UNIQUE键<br></p>

<!--more-->


<p>&emsp;例如：</p>

<pre><code>CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,PRIMARY KEY(ID));
CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,UNIQUE(ID));
</code></pre>

<p><strong>3.BIT位数据类型查询方式</strong><br>
&emsp;bit位数据类型列不能直接查询得出结果，使用bin()显示为二进制格式，或者hex()显示为十六进制格式函数进行读取</p>

<p>&emsp;例如：</p>

<p><img src="/images/mysql/n3.png" alt="" /></p>

<h5>二、日期和时间类型</h5>

<p><img src="/images/mysql/time.png" alt="" /></p>

<p><strong>注意事项:</strong><br>
<strong>1.经常插入或者跟新日期为当前系统时间通常用TIMESTAMP来表示</strong><br>
&emsp;但是MySQL规定TIMESTAMP类型字段只能有一列的默认值为current_timestamp,第二个TIMESTAMP字段的默认值为0，即0000-00-00 00：00：00；时间与时区相关<br></p>

<p><strong>2. DATETIME是DATE和TIME的结合</strong></p>

<pre><code>mysql&gt; create table t(d date,t time,dt datetime);
Query OK, 0 rows affected (0.11 sec)
mysql&gt; desc t;
+-------+----------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| d | date | YES | | NULL | |
| t | time | YES | | NULL | |
| dt | datetime | YES | | NULL | |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql&gt; select now();
+---------------------+
| now() |
+---------------------+
| 2014-04-08 11:38:24 |
+---------------------+
1 row in set (0.01 sec)
mysql&gt; insert into t values(now(),now(),now());
Query OK, 1 row affected, 1 warning (0.00 sec)
mysql&gt; show warnings;
+-------+------+----------------------------------------+
| Level | Code | Message |
+-------+------+----------------------------------------+
| Note | 1265 | Data truncated for column 'd' at row 1 |
+-------+------+----------------------------------------+
1 row in set (0.00 sec)
mysql&gt; select * from t;
+------------+----------+---------------------+
| d | t | dt |
+------------+----------+---------------------+
| 2014-04-08 | 11:38:40 | 2014-04-08 11:38:40 |
+------------+----------+---------------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>3.TIMESTAMP 和DATETIME的区别</strong><br>
&emsp;A.TIMESTAMP支持的范围较小<br>
&emsp;B.表中第一个TIMESTAMP列自动设置为系统时间；如果列中插入NULL或者不明确的赋值都会自动设置该列的值为当前的日期和时间；超过TIMESTAMP的取值范围时，直接由0000-00-00 00：00：00填补<br>
&emsp;C.TIMESTAMP的插入和查询都受当地时区的影响，更能反应实际日期；DATETIME则只能反映出插入时当地的失去，其他时区的人查看数据必然会有误差<br></p>

<p><strong>4.YEAR</strong><br>
&emsp;有4位格式（允许的值是1901~2155、0000，默认值）的年，有2位格式（允许的值70-69，即1970~2069,Mysql5.5.27以后版本不再支持）的年</p>

<h5>三、字符串类型</h5>

<p><img src="/images/mysql/char.png" alt="" /></p>

<p><strong>注意事项：</strong><br>
<strong>1.varchar和char的不同之处在于存储方式不同</strong><br>
&emsp;A. char列的长度固定为创建表时声明的长度，长度可以为0~255；varchar列中的值为可变长字符串，长度可以为0~65535</p>

<p><img src="/images/mysql/charst.png" alt="" /></p>

<p>&emsp;B.查询时char列删除了尾部的空格，而varchar则保留了这些空格<br>
&emsp;例如：</p>

<pre><code>mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.10 sec)
mysql&gt; INSERT INTO vc VALUES ('ab ', 'ab ');
Query OK, 1 row affected (0.00 sec)
mysql&gt; SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab ) | (ab) |
+---------------------+---------------------+
1 row in set (0.00 sec)
mysql&gt; select length(v),length(c) from vc;
+-----------+-----------+
| length(v) | length(c) |
+-----------+-----------+
| 4 | 2 |
+-----------+-----------+
1 row in set (0.00 sec)
mysql&gt; select concat(v,'+'),concat(c,'+') from vc;
+---------------+---------------+
| concat(v,'+') | concat(c,'+') |
+---------------+---------------+
| ab + | ab+ |
+---------------+---------------+
1 row in set (0.00 sec)
</code></pre>

<p><strong>2.BINARY和VARBINARY类型：</strong>类似CHAR和VARCHAR类型，不同的是它们包含二进制字符串而不包含非二进制字符串；CHAR(M)、VARCHAR(M)中的M表示字符长度，BINARY(M)和VARBINARY(M)中M表示字节的长度</p>

<p><strong>3.ENUM类型(枚举类型)</strong><br>
&emsp;对于1~255个成员的枚举需要1个字节存储，对于255~65535个成员，需要2个字节存储，最多允许65535个成员<br>
&emsp;例如:</p>

<p><img src="/images/mysql/enum.png" alt="" /></p>

<p>&emsp;ENUM类型是忽略大小写的，在存储"M" &ldquo;f"时将它们都转换成大写，插入不存在的ENUM指定的范围内的值时，并没有警告，而是插入了enum(&rsquo;M',&lsquo;F&rsquo;)的第一个值“M”，只允许从集合中选取单个值，不能一次取多个</p>

<p><strong>4.SET类型</strong><br>
&emsp;SET是一个字符串对象，包含0~64个成员，与ENUM的区别在于可以一次选取多个成员<br>
&emsp;1~8成员的集合，占1个字节<br>
&emsp;9~16成员的集合，占2个字节<br>
&emsp;17~24成员的集合，占用3个字节<br>
&emsp;25~32成员的集合，占用4个字节<br>
&emsp;33~64成员的集合，占用8个字节<br>
&emsp;例如：</p>

<pre><code>mysql&gt; create table t (col set('a','b','c','d'));
Query OK, 0 rows affected (0.22 sec)
mysql&gt; desc t;
+-------+----------------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+----------------------+------+-----+---------+-------+
| col | set('a','b','c','d') | YES | | NULL | |
+-------+----------------------+------+-----+---------+-------+
1 row in set (0.00 sec)
mysql&gt; insert into t values('a,b'),('a,d,a'),('a,b'),('a,c'),('a');
Query OK, 5 rows affected (0.00 sec)
Records: 5 Duplicates: 0 Warnings: 0
mysql&gt; select * from t;
+------+
| col |
+------+
| a,b |
| a,d |
| a,b |
| a,c |
| a |
+------+
5 rows in set (0.00 sec)
</code></pre>

<p>对于(&lsquo;a,d,a&rsquo;)这样包含重复成员的集合将取一次，写入后的结果为“a,d”</p>

<blockquote><p><a href="http://dev.mysql.com/doc/refman/5.5/en/data-types.html">http://dev.mysql.com/doc/refman/5.5/en/data-types.html</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sql基础操作总结]]></title>
    <link href="http://geekwolf.github.io/blog/2014/04/04/sqlji-chu-cao-zuo-zong-jie/"/>
    <updated>2014-04-04T10:29:01+08:00</updated>
    <id>http://geekwolf.github.io/blog/2014/04/04/sqlji-chu-cao-zuo-zong-jie</id>
    <content type="html"><![CDATA[<p>本文主要根据自己的学习过程总结的文章，可能并不全面，牛人请绕过~<br>
show create table user \G;      查看创建user表的sql<br>
<strong>修改表结构：</strong></p>

<pre><code>alter  table tablename modify[culumn] column_definition [first|after col_name]
例子：
修改emp的字段数据类型
alter table  emp modify ename varchar(20);
表首增加字段
alter table emp add column id int(10) first;
删除字段
alter table emp drop [column]  id;
字段改名 
alter table tablename change [column] old_name column_definition [first/after col_name]
更改表名
alter table emp rename [to] test;
</code></pre>

<p><strong>注释：</strong> modify只能修改字段数据类型，不能修改字段名称，first/after 表示修改字段的顺序</p>

<!--more-->


<p><strong>插入操作:</strong></p>

<pre><code>insert into table emp(f1,f2,f3) values(v1,v2,v3);
insert into table  emp values(v1,v2,v3);
一次插入多条记录
insert into table emp(f1,f2,f3)
values
(r1_v1,r2_v1,r3_v1),
(r1_v2,r2_v2,r3_v3);
</code></pre>

<p><strong>查询：</strong><br>
1.查询不重复记录 distinct</p>

<pre><code>select distinct deptno from emp;
</code></pre>

<p>2.条件查询 where<br/>
where字段比较 >、&lt;、>=、&lt;=、!= 等，多条件用or、and等
3.排序和限制 order by
排序关键字（默认是升序排列）：<br>
&emsp;&emsp;DESC 表示按照字段进行降序排列<br>
&emsp;&emsp;ASC   表所升序排列<br>
&emsp;&emsp;limit  n显示前N条记录
4.聚合操作</p>

<pre><code>语法： select [fidled1,field2,...,fieldn] fun_name
from  tablename
[where where_contition]
[group by  field1,field2,...fieldn]
[with rollup]
[having where_contition]

fun_name :表示做聚合操作的函数，比如：sum、count（*）、max、min
group by  :表示要进行分类聚合的字段
with follup ：可选，表示是否对分类聚合后的结果进行在汇总
having  ：表示在对分类后的结果在进行条件的过滤
</code></pre>

<p><strong>having和where的区别</strong><br>
&emsp;&emsp;having是对聚合后的结果进行条件的过滤，而where是在聚合前就对记录进行过滤，如果逻辑允许，我们尽可能用where先过滤记录，这样因为结果集减小，将对聚合的效率大大提高，最后在根据逻辑看是否用having进行再过滤</p>

<pre><code>例如：
 统计各个部门的人数：
 select deptno,count(1) from emp group by deptno;
 统计各个部门的人数，又要统计总人数:
 select deptno,count(1) from emp group by deptno with rollup;
 统计人数大于1的部门：
 select deptno,count(1) from emp group by deptno having count(1)&gt;1;
 统计公司所有员工的薪水总额、最高和最低薪水
 select sum(sal),max(sal),min(sal) from emp;
</code></pre>

<p>5.表连接<br>
&emsp;&emsp;表连接分为：内连接和外连接；内连接：仅选出两张表中互相匹配的记录；外连接：选出其他不匹配的记录</p>

<pre><code>例如：
 查询雇员的名字和所在部门名称（雇员和部门分属于两个表）
 select ename,deptname from emp,dept where emp.deptno=dept.deptno;
   外连接分为： 
   左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录
   右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录

例如：查询emp中所有用户和所在部门名称
select ename,deptname from dept right join emp on dept.deptno=emp.deptno;
或可用左连接代替
select ename,deptname from emp left join dept on emp.deptno=dept.deptno;
</code></pre>

<blockquote><p>表连接的好文章：
<a href="http://coolshell.cn/articles/3463.html">http://coolshell.cn/articles/3463.html</a><br>
MySQL的联结（Join）语法：
<a href="http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html">http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html</a>
6.子查询
用于子查询的关键字包括in、not in、=、!=、exits、not exits等</p></blockquote>

<pre><code>例如：
从emp表中查询出所有部门在dept表中的所有记录
select * from emp where deptno in(select deptno from dept);
可以使用表连接替换：
select emp.*  from emp,dept where emp.deptno=dept.deptno;

查询记录数唯一，可用=代替in
select * from emp where deptno = (select deptno from dept limit 1);
</code></pre>

<p>6.记录联合（union、union all）
场景：将两个表的数据按照一定的查询条件查询出来后，在合并显示
union和union all的区别在于union all把结果集直接合并在一起，而union是将union all后的结果进行了去重DISTINCT后的结果
<img src="/images/mysql/unionall.png" alt="" /><br>
<strong>查看帮助：</strong></p>

<pre><code>显示可供查询的分类
mysql&gt;? contents

针对某个分类查看帮助
mysql&gt;? data types

查看int数据类型介绍
mysql&gt;? int

查看关键字的语法
mysql&gt;? show
mysql&gt;? create table
</code></pre>
]]></content>
  </entry>
  
</feed>
